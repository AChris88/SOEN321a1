package cipher;

import java.nio.charset.StandardCharsets;
import java.util.Base64;

/**
 * This is a class used to programatically solve 1.3 C of Assignment 1. An
 * AES256 cookie encrypted with OFB must be altered without knowing k or IV. The
 * original cookie as well as the original ciphertext are known.
 * 
 * @author George Lambadas 27077076
 * @author Christian Allard 27026188
 * @created 10/10/2015
 * @edited 16/10/2015
 * 
 */
public class AES256 {

	// Question 1.3a
	// Pu before being converted to Cu
	private static String plaintextAnonCookie = "user=anonymous,tmstmp=1443657660";
	// Pa before being converted to Ca
	private static String authenticatedCookie = "user=admin,tmstmp=1443657660";
	// The difference observed is that the string length is clearly 4 characters
	// shorter.
	// However, as a result, this may (will) change the length of the generated
	// cipher.
	// That being said, given the length of the cipher, we could potentially
	// infer (unless the user's name has as many characters as the word
	// 'anonymous') if the cookie belongs to an anonymous user or not given that
	// the cipher length for anonymous users is known to be 44 characters long.
	// This will remain true until the timestamp value has an extra digit added
	// to it.

	// Cu generated from the above Pu
	private static String base64Cipher = "40mO35Yj9cAMFaaOcshT10VwVw6WmbvAEyrI6TxElFY=";

	/**
	 * Driver method for editing the cookie.
	 * 
	 * @param args
	 *            command line arguments. Not used
	 */
	public static void main(String[] args) {
		// TODO base64Decrypt(base64Cipher);
		somethingElse();
	}

	/**
	 * 
	 */
	private static void somethingElse() {
		byte[] cipher = Base64.getDecoder().decode(base64Cipher);
		byte[] anonBytes = plaintextAnonCookie.getBytes();
		byte[] authBytes = authenticatedCookie.getBytes();
		byte[] authCipherBytes = new byte[authBytes.length];

		System.out.println("original: " + base64Cipher);
		for (int j = 0; j < 4; j++) {
			for (int i = 0; i < authBytes.length; i++) {
				authCipherBytes[i] = (byte) ((anonBytes[i + j] ^ cipher[i + j]) ^ authBytes[i]);
			}
			System.out.println("option#" + (j+1) + ": "
					+ new String(Base64.getEncoder().encode(authCipherBytes)));
		}
	}

	/**
	 * 
	 * 
	 * @param cipher
	 */
	private static void base64Decrypt(String cipher) {

		byte[] anonBytes = plaintextAnonCookie.getBytes(StandardCharsets.UTF_8);
		byte[] base64Anon = Base64.getEncoder().encodeToString(anonBytes)
				.getBytes(), base64Cipher = cipher.getBytes(), base64Admin = Base64
				.getEncoder().encodeToString(authenticatedCookie.getBytes())
				.getBytes(), base64NewCipher = new byte[base64Anon.length];
		System.out.println("NOTE: All of the values below are base64 encoded.");
		System.out.println("Anonymous cookie: \n"
				+ new String(new String(base64Anon)
						.getBytes(StandardCharsets.UTF_8)));
		System.out.println("Ciphertext for anonymous cookie: \n"
				+ new String(new String(base64Cipher)
						.getBytes(StandardCharsets.UTF_8)));
		System.out.println("Authenticated cookie: \n"
				+ new String(new String(base64Admin)
						.getBytes(StandardCharsets.UTF_8)));

		// Keystream blocks are generated by performing an XOR with the
		// anonymous cookie base64 and the ciphertext. The keystream blocks are
		// then XORed with the authenticated cookie base64 resulting in new
		// ciphertext.

		for (int i = 0; i < base64Anon.length - 1; i++) {
			if (i < base64Admin.length) {
				// XOR to get keystream byte, then again to get new ciphertext
				base64NewCipher[i] = (byte) ((base64Anon[i] ^ base64Cipher[i]) ^ base64Admin[i]);
			} else {
				// XOR to get keystream byte but the base64 authenticated key is
				// shorter so it's effectively an XOR with nothing to get the
				// tail of the new ciphertext
				base64NewCipher[i] = (byte) (base64Anon[i] ^ base64Cipher[i]);
			}
		}
		// tack on the =
		base64NewCipher[base64NewCipher.length - 1] = '=';

		System.out.println("Ciphertext for authenticated cookie: \n"
				+ new String(new String(base64NewCipher)
						.getBytes(StandardCharsets.UTF_8)));

	}
}
